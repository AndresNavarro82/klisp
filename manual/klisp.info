This is ../klisp.info, produced by makeinfo version 4.13 from
klisp.texi.

This file documents klisp.

   This is edition 0.1 of the klisp Reference Manual, for klisp version
0.1.

   Copyright (C) 2011 Andres Navarro

   Permission is granted to copy and distribute this manual, in whole or
in part.


File: klisp.info,  Node: Top,  Next: License,  Prev: (dir),  Up: (dir)

   This Info file contains edition 0.1 of the klisp Reference Manual,
corresponding to klisp version 0.1.

   Copyright (C) 2011 Andres Navarro

   Permission is granted to copy and distribute this manual, in whole or
in part.

* Menu:

* License::                 Conditions for copying and changing klisp.
* Introduction::            Introduction and conventions used.
* Booleans::                Boolean module features.
* Equivalence::             Equivalence under mutation & Equivalence up to
mutation module features.
* Symbols::                 Symbol module features.
* Control::                 Control module features.
* Index::                   Index including concepts, functions, variables,
                              and other terms.


File: klisp.info,  Node: License,  Next: Introduction,  Prev: Top,  Up: Top

   klisp is licensed under the terms of the MIT license reproduced
below.  This means that klisp is free software and can be used for both
academic and commercial purposes at absolutely no cost.  The two
projects whose code klisp uses, Lua & IMath, are also distributed under
the MIT license.

   * klisp Parts: Copyright (C) 2011 Andres Navarro.

   * Lua Parts: Copyright (C) 1994-2010 Lua.org, PUC-Rio.

   * IMath Parts: Copyright (C) 2002-2007 Michael J. Fromberger.

   * srfi-78: Copyright (C) 2005-2006 Sebastian Egner.

MIT/X11 License
***************

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


File: klisp.info,  Node: Introduction,  Next: Booleans,  Prev: License,  Up: Top

1 Introduction
**************

klisp is an open source interpreter for the Kernel Programming
Language.  It aims at being comprehensive and robust as specified in
the `Revised(-1) Report on the Kernel Programming Language', but that
probably won't happen for some time.  It is written in C99 under the
MIT license.  It draws heavily from the Lua interpreter source code &
file structure.  It uses the IMath library for arbitrary sized integers
and rationals.

   The Kernel programming language is a statically scoped and properly
tail-recursive dialect of Lisp, descended from Scheme.  It is designed
to be simpler and more general than Scheme, with an exceptionally
clear, simple, and versatile semantics, only one way to form compound
expressions, and no inessential restrictions on the power of that one
compound form.  Imperative, functional, and message-passing programming
styles (to name a few) may be conveniently expressed in Kernel.

   An important property of Kernel is that all manipulable entities in
Kernel are first-class objects.  In particular, Kernel has no
second-class combiners; instead, the roles of special forms and macros
are subsumed by operatives, which are first-class, statically scoped
combiners that act directly on their unevaluated operands.  Kernel also
has a second type of combiners, applicatives, which act on their evalu-
ated arguments.  Applicatives are roughly equivalent to Scheme
procedures.  However, an applicative is nothing more than a wrapper to
induce operand evaluation, around an underlying operative (or, in
principle, around another applicative, though that isnâ€™t usually done);
applicatives themselves are mere facilitators to computation.

   You can read more about Kernel at
`http://web.cs.wpi.edu/~jshutt/kernel.html'.

   klisp is freely available for both academic and commercial purposes.
See LICENSE for details.  it can be downloaded at
`http://www.bitbucket.org/AndresNavarro/klisp'

   klisp is developed by Andres Navarro, a Computer Science
undergraduate at Buenos Aires University (UBA).  You can reach him at
<canavarro82@gmail.com>.

   This manual describes klisp version 0.1, presuming some familiarity
with the Lisp family of languages in general, and with the Kernel
Programming Language in particular.  There are frequent references to
the Kernel Programming Language Report.  Unlike in the report, no
rationale is provided for any feature, only a description of the
implemented functionality.

   This is edition 0.1.

* Menu:

* Caveats::                Flaws and a request for help.
* Kernel History::         Kernel is descended from Scheme.
* Conventions::            How the manual is formatted.
* Acknowledgements::       Contributions to this manual.


File: klisp.info,  Node: Caveats,  Next: Kernel History,  Prev: Introduction,  Up: Introduction

1.1 Caveats
===========

This is the first draft of this manual.  It will be incomplete for some
time.  It will also evolve, together with klisp and the Kernel
Programming Language, both of which, right now, are in a quite fluid
state.

   The main reference on Kernel is the preliminary report: `Revised(-1)
Report on the Kernel Programming Language'.  Some sections of the
report are still incomplete, so both klisp and this manual will use
specifications from other languages in these sections, trying to follow
the Kernel spirit.  These instances will be documented throughout the
manual.

   Please mail comments and corrections to <canavarro82@gmail.com>.


      -Andres Navarro


File: klisp.info,  Node: Kernel History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Kernel History
==================

The Kernel Programming Language is a work in progress.  It is being
developed by John N. Shutt, Ph.D, who created it while studying at the
Worcester Polytechnic Institute (I think about 2002, or so... ASK).  It
is descended from scheme, with the idea that all objects should be
first class values.  In particular, Kernel replaces macros with
operatives (kinda like statically scoped fexprs and fsubrs) and has
first class environments.  Kernel also has the notion of encapsulated
objects which limits the ammount of information an implementation can
share with a Kernel program (e.g. There is no way in Kernel to get the
parents or a complete list of bindings of an environment object).

   The main reference on Kernel is the preliminary report: `Revised(-1)
Report on the Kernel Programming Language'.  Some sections of the
report are still incomplete, so both klisp and this manual will use
specifications from other languages in these sections, trying to follow
the Kernel spirit.  These instances will be documented throughout the
manual.

   You can read all about Kernel at John's homepage at WPI
`http://www.cs.wpi.edu/~jshutt/', including the preliminary report on
the language and his doctoral dissertation which gives a theorethical
frame for fexprs.  You can contact him at <jshutt@cs.wpi.edu>.


File: klisp.info,  Node: Conventions,  Next: Acknowledgements,  Prev: Kernel History,  Up: Introduction

1.3 Conventions
===============

This section explains the notational conventions that are used in this
manual.  You may want to skip this section and refer back to it later.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use for examples that print output.
* Error Messages::           The format we use for examples of errors.
* Format of Descriptions::   Notation for describing functions, variables, etc.


File: klisp.info,  Node: Some Terms,  Next: Evaluation Notation,  Prev: Conventions,  Up: Conventions

1.3.1 Some Terms
----------------

Throughout this manual, the phrases "the Kernel reader" and "the Kernel
printer" are used to refer to those routines in Lisp that convert
textual representations of Kernel objects into actual objects, and vice
versa.  XXX Printed Representation XXX, for more details.  You, the
person reading this manual, are assumed to be "the programmer" or "the
user".

   Examples of Kernel code appear in this font or form: `(list 1 2 3)'.
Names that represent arguments or metasyntactic variables appear in
this font or form: FIRST-NUMBER.


File: klisp.info,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 Evaluation Notation
-------------------------

When you evaluate a piece of Kernel code, it produces a result.  In the
examples in this manual, this is indicated with `=>':

     (car (cons 1 2))
          => 1

You can read this as "`(car (cons 1 2))' evaluates to 1".

   The semantics of a language feature are sometimes clarified, or even
defined, in its entry by specifying that two expressions are
equivalent.  This is notated with `=='.  For example, the semantics of
applicative list* can be defined by following equivalences:
     (list* arg1) == arg1
     (list* arg1 . more-args) == (cons arg1 (list* . more-args))
   Notice that in these kind of examples the applicatives or operatives
referred to are the first class values and not the symbols bound to
them in the ground environment.  This definition would hold even if
`cons' or `list*' were redefined in the current dynamic environment.


File: klisp.info,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.3 Printing Notation
-----------------------

Many of the examples in this manual print text when they are evaluated.
In examples that print text, the printed text is indicated with `-|'.
The value returned by evaluating the form (here `#t') follows on a
separate line.

     ($sequence (write 1) (write 2) #t)
          -| 1
          -| 2
          => #t


File: klisp.info,  Node: Error Messages,  Next: Format of Descriptions,  Prev: Printing Notation,  Up: Conventions

1.3.4 Error Messages
--------------------

Some examples cause errors to be signaled.  The report doesn't specify
what objects are passed to the error continuation, but in klisp,
objects passed to the error continuation are encapsulated error objects
that have at least a message and possibly some additional objects and
context informations (such as source code location).  In the examples,
the error message is shown on a line starting with `error-->'.

     (+ 23 #t)
     error--> Wrong type argument: (expected number) (#t)


File: klisp.info,  Node: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.5 Format of Descriptions
----------------------------

Applicatives, operatives, and other objects are described in this manual
in a uniform format.  The first line of a description contains the name
of the item followed by its operands or arguments, if any.  The
category--operative, applicative, or whatever--appears at the beginning
of the line.  The description follows on succeeding lines, sometimes
with examples.

* Menu:

* A Sample Applicative Description::


File: klisp.info,  Node: A Sample Applicative Description,  Prev: Format of Descriptions,  Up: Format of Descriptions

1.3.5.1 A Sample Applicative Description
........................................

In an applicative description, the name of the applicative being
described appears first.  It is followed on the same line by an
applicative combination that includes the name of the applicative and
the arguments, as would appear in a program.  The names used for the
arguments are also used in the body of the description.

   Here is a description of an imaginary applicative `foo':

 -- Applicative: foo (foo integer1 integer2 . rest)
     The applicative `foo' subtracts INTEGER1 from INTEGER2, then adds
     all the rest of the arguments to the result.

          (foo 1 5 3 9)
               => 16

     More generally,

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

   Any parameter whose name contains the name of a type (e.g., INTEGER,
INTEGER1 or CONTINUATION) is expected to be of that type.  A plural of
a type (such as NUMBERS) often means a list of objects of that type.
Parameters named OBJECT may be of any type.  (XXX Types of Lisp Object
XXX, for a list of Kernel object types.)  Parameters with other sorts
of names are discussed specifically in the description of the combiner.
In some sections, features common to parameters of several combiners are
described at the beginning.

   Operative descriptions have the same format, but the word
`Applicative' is  replaced by `Operative', and `Argument' is replaced
by `Operand'.  Also Operatives always have an environment parameter
(that can be #ignore or a symbol).


File: klisp.info,  Node: Acknowledgements,  Prev: Conventions,  Up: Introduction

1.4 Acknowledgements
====================

This manual was written by Andres Navarro.

   The structure and some text for this introductory section were
borrowed from the Elisp Manual by the Free Sofware Foundation.  This
manual also borrows freely from both the Kernel Report and the Scheme
Reports.


File: klisp.info,  Node: Booleans,  Next: Equivalence,  Prev: Introduction,  Up: Top

2 Booleans
**********

The boolean data type consists of two values, which are called true and
false, and have respectively external representations `#t' and `#f'.
There are no possible mutations of either of these two values, and the
boolean type is encapsulated.

 -- Applicative: boolean? (boolean? . objects)
     The primitive type predicate for type boolean.  `boolean?' returns
     true iff all the objects in `objects' are of type boolean.

 -- Applicative: not? (not? boolean)
     Applicative `not?' is a predicate that returns the logical
     negation of its argument.

 -- Applicative: and? (and? . booleans)
     Applicative `and?' is a predicate that returns true unless one or
     more of its arguments are false.

 -- Applicative: or? (or? . booleans)
     Applicative `or?' is a predicate that returns false unless one or
     more of its arguments are true.

 -- Operative: $and? ($and? . <list>)
     The `$and?' operative performs a "short-circuit and" of its
     operands.  It evaluates them from left to right, until either an
     operand evaluates to false, or the end of the list is reached.  If
     the end of the list is reached (which is immediate if `<list>' is
     `nil'), the operative returns true.  If an operand evaluates to
     false, no further operand evaluations are performed, and the
     operative returns false.  If `<list>' is acyclic, and the last
     operand is evaluated, it is evaluated as a tail context.  If
     `<list>' is cyclic, an unbounded number of operand evaluations may
     be performed.  If any of the operands evaluates to a non-boolean
     value, an error is signaled (even if it's the last one).

 -- Operative: $or? ($or? . <list>)
     The `$or?' operative performs a "short-circuit or" of its
     operands.  It evaluates them from left to right, until either an
     operand evaluates to true, or the end of the list is reached.  If
     the end of the list is reached (which is immediate if `<list>' is
     `nil'), the operative returns false.  If an operand evaluates to
     true, no further operand evaluations are performed, and the
     operative returns true.  If `<list>' is acyclic, and the last
     operand is evaluated, it is evaluated as a tail context.  If
     `<list>' is cyclic, an unbounded number of operand evaluations may
     be performed.  If any of the operands evaluates to a non-boolean
     value, an error is signaled (even if it's the last one).


File: klisp.info,  Node: Equivalence,  Next: Symbols,  Prev: Booleans,  Up: Top

3 Equivalence
*************

Kernel has two general-purpose equivalence predicates (whereas R5RS
Scheme has three).  The two Kernel predicates correspond to the
abstract notions of equivalence up to mutation (`equal') and
equivalence in the presence of mutation (`eq?').

 -- Applicative: eq? (eq? . objects)
     Predicate `eq?' returns true iff all of `objects' are effectively
     the same object, even in the presence of mutation.

 -- Applicative: equal? (equal? . objects)
     Predicate `equal?' returns true iff all of `objects' "look" the
     same as long as nothing is mutated.  This is a weaker predicate
     than `eq?'; that is, `equal?' must return true whenever `eq?'
     would return true.


File: klisp.info,  Node: Symbols,  Next: Control,  Prev: Equivalence,  Up: Top

4 Symbols
*********

Two symbols are eq? iff they have the same external representation.
Symbols are immutable, and the symbol type is encapsulated.  The
external representations of symbols are usually identifiers.  However,
symbols with other external representations may be created.

 -- Applicative: symbol? (symbol? . objects)
     The primitive type predicate for type symbol. `symbol?' returns
     true iff all the objects in `objects' are of type symbol.

 -- Applicative: symbol->string (symbol->string symbol)
     Applicative `symbol->string' returns the name of `symbol' as a
     string.  The string returned is immutable.

 -- Applicative: string->symbol (string->symbol string)
     Applicative `string->symbol' returns the symbol with name
     `string'.  The symbol is always interned, which means, that it is
     always the case that:
          (eq? <symbol> (string->symbol (symbol->string <symbol>)))
               => #t
       `string->symbol' can create symbols whose external
     representation aren't identifiers.  Right now klisp uses an
     output-only representation, but in the near future it will
     probably include some kind of escaping mechanism to allow
     arbitrary symbols to have readable external representations as in
     R7RS Scheme.


File: klisp.info,  Node: Control,  Next: Index,  Prev: Symbols,  Up: Top

5 Control
*********

The inert data type is provided for use with control combiners.  It
consists of a single immutable value, having external representation
`#inert'.  The inert type is encapsulated.

 -- Applicative: inert? (inert? . objects)
     The primitive type predicate for type inert. `inert?' returns true
     iff all the objects in `objects' are of type inert.

 -- Operative: $if ($if <test> <consequent> <alternative>)
     The `$if' operative first evaluates `<test>' in the dynamic
     environment.  If the result is not of type boolean, an error is
     signaled.  If the result is true, `<consequent>' is then evaluated
     in the dynamic environment as a tail context.  Otherwise,
     `<alternative>' is evaluated in the dynamic environment as a tail
     context.

 -- Operative: $sequence ($sequence . <objects>)
     The `$sequence' operative evaluates the elements of the list
     `<objects>' in the dynamic environment, one at a time from left to
     right.  If `<objects>' is a cyclic list, element evaluation
     continues indefinitely, with elements in the cycle being evaluated
     repeatedly.  If `<objects>' is a nonempty finite list, its last
     element is evaluated as a tail context.  If `<objects>' is the
     empty list, the result is inert.

 -- Operative: $cond ($cond . <clauses>)
     `<clauses>' should be a list of clause expressions, each of the
     form `(<test> . <body>)', where body is a list of expressions.

     The following equivalences define the behaviour of the `$cond'
     operative:
          ($cond) == #inert
          ($cond (<test> . <body>) . <clauses>) ==
            ($if <test> ($sequence . <body>) ($cond . <clauses>))

 -- Applicative: for-each (for-each . lists)
     `lists' must be a nonempty list of lists; if there are two or
     more, they should all be the same length. If lists is empty, or if
     all of its elements are not lists of the same length, an error is
     signaled.

     `for-each' behaves identically to `map', except that instead of
     accumulating and returning a list of the results of the
     element-wise applications, the results of the applications are
     discarded and the result returned by `for-each' is inert.


File: klisp.info,  Node: Index,  Next: (dir),  Prev: Control,  Up: Top

Index
*****

 [index ]
* Menu:

* $and?:                                 Booleans.             (line 28)
* $cond:                                 Control.              (line 32)
* $if:                                   Control.              (line 15)
* $or?:                                  Booleans.             (line 41)
* $sequence:                             Control.              (line 23)
* and?:                                  Booleans.             (line 20)
* applicative descriptions:              A Sample Applicative Description.
                                                               (line  6)
* boolean?:                              Booleans.             (line 12)
* booleans:                              Booleans.             (line  6)
* control:                               Control.              (line  6)
* description format:                    Format of Descriptions.
                                                               (line  6)
* documentation notation:                Evaluation Notation.  (line  6)
* eq?:                                   Equivalence.          (line 12)
* equal?:                                Equivalence.          (line 16)
* equivalence:                           Equivalence.          (line  6)
* error message notation:                Error Messages.       (line  6)
* evaluation notation:                   Evaluation Notation.  (line  6)
* fonts:                                 Some Terms.           (line 13)
* foo:                                   A Sample Applicative Description.
                                                               (line 15)
* for-each:                              Control.              (line 42)
* inert?:                                Control.              (line 11)
* Kernel history:                        Kernel History.       (line  6)
* not?:                                  Booleans.             (line 16)
* object descriptions:                   A Sample Applicative Description.
                                                               (line  6)
* operative descriptions:                A Sample Applicative Description.
                                                               (line  6)
* or?:                                   Booleans.             (line 24)
* printing notation:                     Printing Notation.    (line  6)
* string->symbol:                        Symbols.              (line 20)
* symbol->string:                        Symbols.              (line 16)
* symbol?:                               Symbols.              (line 12)
* symbols:                               Symbols.              (line  6)



Tag Table:
Node: Top302
Node: License1130
Node: Introduction2801
Node: Caveats5624
Node: Kernel History6410
Node: Conventions7855
Node: Some Terms8526
Node: Evaluation Notation9197
Node: Printing Notation10218
Node: Error Messages10694
Node: Format of Descriptions11342
Node: A Sample Applicative Description11906
Node: Acknowledgements13566
Node: Booleans13952
Node: Equivalence16494
Node: Symbols17287
Node: Control18652
Node: Index20959

End Tag Table
