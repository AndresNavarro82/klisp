<html lang="en">
<head>
<title>Ports - klisp Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="klisp Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Characters.html#Characters" title="Characters">
<link rel="next" href="Index.html#Index" title="Index">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Ports"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Index.html#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Characters.html#Characters">Characters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">16 Ports</h2>

<p><a name="index-ports-173"></a>
  A port is an object that mediates character-based input from a
source or character-based output to a destination. In the former case,
the port is an input port, in the latter case, an output port.

<!-- TODO add xref to equal? & eq? -->
   <p>Although ports are not considered immutable, none of the operations
on ports described in this section constitute mutation.  Ports are
<code>equal?</code> iff <code>eq?</code>.  The port type is encapsulated.

   <p>An auxiliary data type used to signal the end of file was reached is
eof. The eof type consists of a single immutable value, having
an output only external representation (so that it can never be the
normal result of a call to read).  The eof type is encapsulated.

   <p>SOURCE NOTE:  the eof type is not in the Kernel report, it is used in
klisp and was taken from Scheme.

<div class="defun">
&mdash; Applicative: <b>port?</b> (<var>port? . objects</var>)<var><a name="index-port_003f-174"></a></var><br>
<blockquote><p>  The primitive type predicate for type port.  <code>port?</code>
returns true iff all the objects in <code>objects</code> are of type port. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>input-port?</b> (<var>input-port? . objects</var>)<var><a name="index-input_002dport_003f-175"></a></var><br>
&mdash; Applicative: <b>output-port?</b> (<var>output-port? . objects</var>)<var><a name="index-output_002dport_003f-176"></a></var><br>
<blockquote><p>  Applicative <code>input-port?</code> is a predicate that returns true
unless one or more of its arguments is not an input port.  Applicative
output-port? is a predicate that returns true unless one or more of
its arguments is not an output port.

        <p>Every port must be admitted by at least one of these two predicates. 
</p></blockquote></div>

<div class="defun">
&mdash; with-input-from-file: <b>(</b><var>with-input-from-file string combiner</var>)<var><a name="index-g_t_0028-177"></a></var><br>
&mdash; with-output-to-file: <b>(</b><var>with-output-to-file string combiner</var>)<var><a name="index-g_t_0028-178"></a></var><br>
<blockquote><!-- add xref get-current-input-port/get-current-output-port -->
        <p>These two applicatives open the file named in <code>string</code> for
input or output, an invoke the binder of the input-port &amp; output-port
keyed dynamic variables respectively with the opened port &amp; the passed
<code>combiner</code> (this means that the combiner is called in a fresh, empty
dynamic environment).  When/if the binder normally returns, the port is closed. 
The result of the applicatives <code>with-input-from-file</code> and
<code>with-output-from-file</code> is inert.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing.  In the new scheme report there's also a third
error-port variable.  It is very likely that that will be added to the
klisp implementation in the near future. 
</p></blockquote></div>

<div class="defun">
&mdash; get-current-input-port: <b>(</b><var>get-current-input-port</var>)<var><a name="index-g_t_0028-179"></a></var><br>
&mdash; get-current-output-port: <b>(</b><var>get-current-output-port</var>)<var><a name="index-g_t_0028-180"></a></var><br>
<blockquote><p>  These are the accessors for the input-port and output-port keyed
dynamic variables repectively. 
<!-- add xref to with-input-from-file, etc -->
<!-- add xref and text for these dynamic vars -->

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing.  In the new scheme report there's also a third
error-port variable.  It is very likely that that will be added to the
klisp implementation in the near future. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-input-file</b> (<var>open-input-file string</var>)<var><a name="index-open_002dinput_002dfile-181"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for an existing file.

        <p>Applicative <code>open-input-file</code> creates and returns an input port
associated with the file represented with <code>string</code>.  If the file
can't be opened (e.g. because it doesn't exists, or there's a
permissions problem), an error is signaled.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-output-file</b> (<var>open-output-file string</var>)<var><a name="index-open_002doutput_002dfile-182"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for an existing file.

        <p>Applicative <code>open-output-file</code> creates and returns an output
port associated with the file represented with <code>string</code>.  If the
file can't be opened (e.g. if there's a permissions problem), an error
is signaled.

        <p>In klisp, for now, applicative <code>open-output-file</code> truncates the
file if it already exists, but that could change later (i.e. like in
scheme the behaviour should be considered unspecified).

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; close-input-file: <b>(</b><var>close-input-file input-port</var>)<var><a name="index-g_t_0028-183"></a></var><br>
&mdash; close-output-file: <b>(</b><var>close-output-file output-port</var>)<var><a name="index-g_t_0028-184"></a></var><br>
<blockquote><p>  These applicatives close the port argument, so that no more
input/output may be performed on them, and the resources can be
freed.  If the port was already closed these applicatives have no
effect.

        <p>The result returned by applicatives <code>close-input-file</code> and
<code>close-output-file</code> is inert.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing.  There's probably a name error here.  These should
probably be called close-input-port &amp; close-output-port. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>read</b> (<var>read </var>[<var>input-port</var>])<var><a name="index-read-185"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>read</code> reads &amp; returns the next parseable object
from the given port, or the eof object if no objects remain.  If
<code>read</code> finds and unparseable object in the port, an error is
signaled.  In that case, the remaining position in the port is
unspecified.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; write: <b>(</b><var>write object </var>[<var>port</var>])<var><a name="index-g_t_0028-186"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

     <!-- TODO add xref to external representation -->
        <p>Applicative <code>write</code> writes an external representation of
<code>object</code> to the specified port.  This may be an output-only
representation that can't be read by applicative <code>read</code> in cases
where the type of <code>object</code> doen't have a parseable external
representation (e.g. combiners and environments).  The result returned
by <code>write</code> is inert.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>call-with-input-file</b> (<var>call-with-input-file string combiner</var>)<var><a name="index-call_002dwith_002dinput_002dfile-187"></a></var><br>
&mdash; Applicative: <b>call-with-output-file</b> (<var>call-with-output-file string combiner</var>)<var><a name="index-call_002dwith_002doutput_002dfile-188"></a></var><br>
<blockquote><p>  These applicatives open file named in <code>string</code> and call their
<code>combiner</code> argument in a fresh empty environment passing it as a
sole operand the opened port.  When/if the combiner normally returns a
value the port is closed and that value is returned as the result of
the applicative.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>load</b> (<var>load string</var>)<var><a name="index-load-189"></a></var><br>
<blockquote><!-- TODO add xref, open/input, read -->
        <p>Applicative <code>load</code> opens for input a file named <code>string</code>;
reads objects from the file until the end of the file is reached;
evaluates those objects consecutively in the created environment.  The
result from applicative <code>load</code> is inert.

        <p>SOURCE NOTE: load is enumerated in the Kernel report, but the
description is not there yet.  This seems like a sane way to define
it, taking the description of <code>get-module</code> that there is in the
report.  The one detail that I think is still open, is whether to
return <code>#inert</code> (as is the case with klisp currently) or rather
return the value of the last evaluation. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>get-module</b> (<var>get-module string </var>[<var>environment</var>])<var><a name="index-get_002dmodule-190"></a></var><br>
<blockquote><!-- TODO add xref standard-environment, open/input, read -->
        <p>Applicative <code>get-module</code> creates a fresh standard environment;
opens for input a file named <code>string</code>; reads objects from the
file until the end of the file is reached; evaluates those objects
consecutively in the created environment; and, lastly, returns the
created environment.  If the optional argument <code>environment</code> is
specified, the freshly created standard environment is augmented,
prior to evaluating read expressions, by binding symbol
<code>module-parameters</code> to the <code>environment</code> argument. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>eof-object?</b> (<var>eof-object? . objects</var>)<var><a name="index-eof_002dobject_003f-191"></a></var><br>
<blockquote><p>  The primitive type predicate for type eof.  <code>eof-object?</code>
returns true iff all the objects in <code>objects</code> are of type eof.

        <p>SOURCE NOTE: This is not in the report, the idea is from Scheme. 
The <code>eof-object?</code> name is also from scheme, but this will
probably be changed to just <code>eof?</code>, for consistency with the other
primitive type predicates. 
</p></blockquote></div>

<div class="defun">
&mdash; read-char: <b>(</b><var>read-char </var>[<var>port</var>])<var><a name="index-g_t_0028-192"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>read-char</code> reads and returns a character (not
an external representation of a character) from the specified port, or
an eof if the end of file was reached.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; peek-char: <b>(</b><var>peek-char </var>[<var>port</var>])<var><a name="index-g_t_0028-193"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>peek-char</code> reads and returns a character (not
an external representation of a character) from the specified port, or
an eof if the end of file was reached.  The position of the port
remains unchanged so that new call to <code>peek-char</code> or
<code>read-char</code> on the same port return the same character.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; char-ready?: <b>(</b><var>char-ready? </var>[<var>port</var>])<var><a name="index-g_t_0028-194"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Predicate <code>char-ready?</code> checks to see if a character is
available in the specified port.  If it returns true, then a
<code>read-char</code> or <code>peek-char</code> on that port is guaranteed not to
block/hang.  For now in klisp this is hardcoded to <code>#t</code> because
the code to do this is non-portable.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; write-char: <b>(</b><var>write-char char </var>[<var>port</var>])<var><a name="index-g_t_0028-195"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>write-char</code> writes the <code>char</code> character (not
an external representation of the character) to the specified port. 
The result returned by <code>write-char</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; newline: <b>(</b><var>newline </var>[<var>port</var>])<var><a name="index-g_t_0028-196"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>newline</code> writes a newline to the specified port. 
The result returned by <code>newline</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; display: <b>(</b><var>display object </var>[<var>port</var>])<var><a name="index-g_t_0028-197"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>display</code> behaves like <code>write</code> except that
strings are not enclosed in double quotes and no character is escaped
within those strings and character objects are output as if by
<code>write-char</code> instead of <code>read</code>. The result returned by
<code>display</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<!-- appendices -->
<!-- TODO -->
<!-- *-texinfo-*- -->
<!-- TODO correct prev node -->
   </body></html>

