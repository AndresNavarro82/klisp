;;;
;;; Basic Functionality
;;;

($check-predicate (applicative? eq?))
($check-predicate (applicative? equal?))

; no arguments
($check-predicate (eq?))

($check-predicate (equal?))

; 1 arguments
($check-predicate (eq? ((unwrap list) . symbol)))
($check-predicate (eq? ()))
($check-predicate (eq? (cons () ())))
($check-predicate (eq? #ignore))
($check-predicate (eq? (make-environment)))
($check-predicate (eq? #inert))
($check-predicate (eq? $vau))
($check-predicate (eq? wrap))
($check-predicate (eq? (call/cc ($lambda (c) c))))
($check-predicate (eq? ($let (((enc . #ignore) 
					(make-encapsulation-type)))
				  (enc #inert))))
($check-predicate (eq? (memoize #inert)))
($check-predicate (eq? 1))
($check-predicate (eq? -1/2))
($check-predicate (eq? 1.0))
($check-predicate (eq? #e+infinity))
($check-predicate (eq? #i+infinity))
($check-predicate (eq? #undefined))
($check-predicate (eq? #real))
($check-predicate (eq? "string"))
($check-predicate (eq? #\a))
($check-predicate (eq? (get-current-input-port)))


($check-predicate (equal? ((unwrap list) . symbol)))
($check-predicate (equal? ()))
($check-predicate (equal? (cons () ())))
($check-predicate (equal? #ignore))
($check-predicate (equal? (make-environment)))
($check-predicate (equal? #inert))
($check-predicate (equal? $vau))
($check-predicate (equal? wrap))
($check-predicate (equal? (call/cc ($lambda (c) c))))
($check-predicate (equal? ($let (((enc . #ignore) 
					(make-encapsulation-type)))
				  (enc #inert))))
($check-predicate (equal? (memoize #inert)))
($check-predicate (equal? 1))
($check-predicate (equal? -1/2))
($check-predicate (equal? 1.0))
($check-predicate (equal? #e+infinity))
($check-predicate (equal? #i+infinity))
($check-predicate (equal? #undefined))
($check-predicate (equal? #real))
($check-predicate (equal? "string"))
($check-predicate (equal? #\a))
($check-predicate (equal? (get-current-input-port)))

; 2 arguments
($check-predicate (eq? ((unwrap list) . symbol) ((unwrap list) . symbol)))
($check-predicate (eq? () ()))
($let ((p (cons () ())))
  ($check-predicate (eq? p p)))
($check-not-predicate (eq? (cons () ()) (cons () ())))
($check-predicate (eq? #ignore #ignore))
($let ((e (make-environment)))
  ($check-predicate (eq? e e)))
($check-not-predicate (eq? (make-environment) (make-environment)))
($check-predicate (eq? #inert #inert))
($check-predicate (eq? $vau $vau))
($check-predicate (eq? wrap wrap))
($let/cc c
  ($check-predicate (eq? c c)))
($let* (((enc . #ignore) 
	(make-encapsulation-type))
	(e (enc #inert)))
  ($check-predicate (eq? e e))
  ($check-not-predicate (eq? e (enc #inert))))
($let ((p (memoize #inert)))
  ($check-predicate (eq? p p))
  ($check-not-predicate (eq? p #inert)))
($check-predicate (eq? 1 1))
($check-predicate (eq? -1/2 -1/2))
($check-predicate (eq? 1.0 1.0))
($check-not-predicate (eq? 1 1.0))
($check-not-predicate (eq? 1/2 0.5))
($check-predicate (eq? #e+infinity #e+infinity))
($check-predicate (eq? #i+infinity #i+infinity))
($check-not-predicate (eq? #e+infinity #i+infinity))
($check-predicate (eq? #undefined #undefined))
($check-predicate (eq? #real #real))
($check-not-predicate (eq? #undefined #real))
($let ((s "string"))
  ($check-predicate (eq? s s)))
($check-not-predicate (eq? (string #\c) (string #\c)))
($check-predicate (eq? #\a #\a))
($check-predicate (eq? (get-current-input-port) (get-current-input-port)))

($check-predicate (equal? ((unwrap list) . symbol) ((unwrap list) . symbol)))
($check-predicate (equal? () ()))
($check-predicate (equal? (cons () ()) (cons () ())))
($let ((p1 (list 1 2 1 2))
       (p2 (list 1 2)))
  (encycle! p1 2 2)
  (encycle! p2 0 2)
  ($check-predicate (equal? p1 p2)))
($check-predicate (equal? #ignore #ignore))
($let ((e (make-environment)))
  ($check-predicate (equal? e e)))
($check-not-predicate (equal? (make-environment) (make-environment)))
($check-predicate (equal? #inert #inert))
($check-predicate (equal? $vau $vau))
($check-predicate (equal? wrap wrap))
($let/cc c
  ($check-predicate (equal? c c)))
($let* (((enc . #ignore) 
	(make-encapsulation-type))
	(e (enc #inert)))
  ($check-predicate (equal? e e))
  ($check-not-predicate (equal? e (enc #inert))))
($let ((p (memoize #inert)))
  ($check-predicate (equal? p p))
  ($check-not-predicate (equal? p #inert)))
($check-predicate (equal? 1 1))
($check-predicate (equal? -1/2 -1/2))
($check-predicate (equal? 1.0 1.0))
($check-not-predicate (equal? 1 1.0))
($check-not-predicate (equal? 1/2 0.5))
($check-predicate (equal? #e+infinity #e+infinity))
($check-predicate (equal? #i+infinity #i+infinity))
($check-not-predicate (equal? #e+infinity #i+infinity))
($check-predicate (equal? #undefined #undefined))
($check-predicate (equal? #real #real))
($check-not-predicate (equal? #undefined #real))
($let ((s "string"))
  ($check-predicate (equal? s s)))
($check-predicate (equal? "string" "string"))
($check-predicate (equal? (string #\c) (string #\c)))
($check-predicate (equal? #\a #\a))
($check-predicate (equal? (get-current-input-port) (get-current-input-port)))

; 3 or more arguments
($check-predicate (eq? 1 1 1))
($check-not-predicate (eq? #t #t #f))
($check-predicate (eq? #t #t . #0=(#t . #0#)))
($check-not-predicate (eq? #t #t . #0=(#inert . #0#)))

($check-predicate (equal? 1 1 1))
($check-not-predicate (equal? #t #t #f))
($check-predicate (equal? #t #t . #0=(#t . #0#)))
($check-not-predicate (equal? #t #t . #0=(#inert . #0#)))

($let ((p1 (list 1 2 1 2))
       (p2 (list 1 2)))
  (encycle! p1 2 2)
  (encycle! p2 0 2)
  ($check-predicate (equal? p1 p2 . #0=(p2 p1 . #0#))))

;;;
;;; Error Checking and Robustness
;;;

;; boolean?
($check-error (eq? #t . #f))

($check-error (equal? #t . #f))
