<html lang="en">
<head>
<title>Ports - klisp Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="klisp Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Characters.html#Characters" title="Characters">
<link rel="next" href="Alphabetical-Index.html#Alphabetical-Index" title="Alphabetical Index">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Ports"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Alphabetical-Index.html#Alphabetical-Index">Alphabetical Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Characters.html#Characters">Characters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">17 Ports</h2>

<p><a name="index-ports-293"></a>
  A port is an object that mediates data from an input or to a
destination.  In the former case, the port is an input port, in the
latter case, an output port.  The data itself can consist of either
characters or bytes.  In the former case the port is a textual port
and in the latter case, a binary port.

   <p>There are three textual ports open, binded by dynamic variables, one
for standard input, output, and error.

<!-- TODO add xref to equal? & eq? -->
   <p>Although ports are not considered immutable, none of the operations
on ports described in this section constitute mutation.  Ports are
<code>equal?</code> iff <code>eq?</code>.  The port type is encapsulated.

   <p>An auxiliary data type used to signal the end of file was reached is
<code>eof</code>. The eof type consists of a single immutable value, having
an output only external representation (so that it can never be the
normal result of a call to read).  The eof type is encapsulated.

   <p>SOURCE NOTE:  the eof type is not in the Kernel report, it is used in
klisp and was taken from r7rs.

<div class="defun">
&mdash; Applicative: <b>port?</b> (<var>port? . objects</var>)<var><a name="index-port_003f-294"></a></var><br>
<blockquote><p>  The primitive type predicate for type port.  <code>port?</code>
returns true iff all the objects in <code>objects</code> are of type port. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>input-port?</b> (<var>input-port? . objects</var>)<var><a name="index-input_002dport_003f-295"></a></var><br>
&mdash; Applicative: <b>output-port?</b> (<var>output-port? . objects</var>)<var><a name="index-output_002dport_003f-296"></a></var><br>
<blockquote><p>  Applicative <code>input-port?</code> is a predicate that returns true
unless one or more of its arguments is not an input port.  Applicative
<code>output-port?</code> is a predicate that returns true unless one or
more of its arguments is not an output port.

        <p>Every port must be admitted by at least one of these two predicates. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>textual-port?</b> (<var>textual-port? . objects</var>)<var><a name="index-textual_002dport_003f-297"></a></var><br>
&mdash; Applicative: <b>binary-port?</b> (<var>binary-port? . objects</var>)<var><a name="index-binary_002dport_003f-298"></a></var><br>
<blockquote><p>  Applicative <code>textual-port?</code> is a predicate that returns true
unless one or more of its arguments is not a textual port.  Applicative
<code>binary-port?</code> is a predicate that returns true unless one or more of
its arguments is not a binary port.

        <p>Every port must be admitted by at least one of these two predicates.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from r7rs. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>file-port?</b> (<var>file-port? . objects</var>)<var><a name="index-file_002dport_003f-299"></a></var><br>
&mdash; Applicative: <b>string-port?</b> (<var>string-port? . objects</var>)<var><a name="index-string_002dport_003f-300"></a></var><br>
&mdash; Applicative: <b>bytevector-port?</b> (<var>bytevector-port? . objects</var>)<var><a name="index-bytevector_002dport_003f-301"></a></var><br>
<blockquote><p>These applictives are predicates that returns true unless one or more
of its arguments is not file, string or bytevector port, repectively.

        <p>Every port in klisp is be admitted by exactly one of these predicates.

        <p>SOURCE NOTE: this is missing from Kernel. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>port-open?</b> (<var>port-open? port</var>)<var><a name="index-port_002dopen_003f-302"></a></var><br>
<blockquote><p>Applicative <code>port-open?</code> returns true iff <code>port</code> is still
open. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>with-input-from-file</b> (<var>with-input-from-file string combiner</var>)<var><a name="index-with_002dinput_002dfrom_002dfile-303"></a></var><br>
&mdash; Applicative: <b>with-output-to-file</b> (<var>with-output-to-file string combiner</var>)<var><a name="index-with_002doutput_002dto_002dfile-304"></a></var><br>
&mdash; Applicative: <b>with-error-to-file</b> (<var>with-error-to-file string combiner</var>)<var><a name="index-with_002derror_002dto_002dfile-305"></a></var><br>
<blockquote><!-- add xref get-current-input-port/get-current-output-port -->
        <p>These three applicatives open the file named in <code>string</code> for
textual input or output, an invoke the binder of either the
input-port, the output-port or the error-port keyed dynamic variables
respectively with the opened port &amp; the passed <code>combiner</code> (this
means that the combiner is called in a fresh, empty dynamic
environment).  When/if the binder normally returns, the port is
closed.  The result of the applicatives <code>with-input-from-file</code>
and <code>with-output-from-file</code> is inert.

        <p>SOURCE NOTE: The first two are enumerated in the Kernel report but
the text is still missing.  The third applicative is from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>get-current-input-port</b> (<var>get-current-input-port</var>)<var><a name="index-get_002dcurrent_002dinput_002dport-306"></a></var><br>
&mdash; Applicative: <b>get-current-output-port</b> (<var>get-current-output-port</var>)<var><a name="index-get_002dcurrent_002doutput_002dport-307"></a></var><br>
&mdash; Applicative: <b>get-current-error-port</b> (<var>get-current-error-port</var>)<var><a name="index-get_002dcurrent_002derror_002dport-308"></a></var><br>
<blockquote><p>  These are the accessors for the input-port, output-port, and
error-port keyed dynamic variables repectively. 
<!-- add xref to with-input-from-file, etc -->
<!-- add xref and text for these dynamic vars -->

        <p>SOURCE NOTE: The first two are enumerated in the Kernel report but
the text is still missing.  The third applicative is from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-input-file</b> (<var>open-input-file string</var>)<var><a name="index-open_002dinput_002dfile-309"></a></var><br>
&mdash; Applicative: <b>open-binary-input-file</b> (<var>open-binary-input-file string</var>)<var><a name="index-open_002dbinary_002dinput_002dfile-310"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for an existing file.

        <p>Applicative <code>open-input-file</code> creates and returns a textual
input port associated with the file represented with <code>string</code>. 
Applicative <code>open-binary-input-file</code> creates and returns a binary
input port associated with the file represented with <code>string</code>. 
In either case, if the file can't be opened (e.g. because it doesn't
exists, or there's a permissions problem), an error is signaled.

        <p>SOURCE NOTE: open-input-file is enumerated in the Kernel report but
the text is still missing. open-binary-input-file is from r7rs. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-output-file</b> (<var>open-output-file string</var>)<var><a name="index-open_002doutput_002dfile-311"></a></var><br>
&mdash; Applicative: <b>open-binary-output-file</b> (<var>open-binary-output-file string</var>)<var><a name="index-open_002dbinary_002doutput_002dfile-312"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for an existing file.

        <p>Applicative <code>open-output-file</code> creates and returns a textual
output port associated with the file represented with <code>string</code>. 
Applicative <code>open-binary-output-file</code> creates and returns a
binary output port associated with the file represented with
<code>string</code>.  In either case, if the file can't be opened (e.g. if
there's a permissions problem), an error is signaled.

        <p>In klisp, for now, applicative <code>open-output-file</code> and
<code>open-binary-output-file</code> truncate the file if it already exists,
but that could change later (i.e. like in Scheme the behaviour should
be considered unspecified).

        <p>SOURCE NOTE: open-output-file is enumerated in the Kernel report but
the text is still missing. open-binary-output-file is from r7rs. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-input-string</b> (<var>open-output-string string</var>)<var><a name="index-open_002dinput_002dstring-313"></a></var><br>
&mdash; Applicative: <b>open-input-bytevector</b> (<var>open-output-bytevector bytevector</var>)<var><a name="index-open_002dinput_002dbytevector-314"></a></var><br>
<blockquote><p>These applicative return a fresh input port that reads characters or
unsigned bytes from the passed sequence.

        <p>SOURCE NOTE: These are taken from r7rs. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>open-output-string</b> (<var>open-output-string</var>)<var><a name="index-open_002doutput_002dstring-315"></a></var><br>
&mdash; Applicative: <b>open-output-bytevector</b> (<var>open-output-bytevector</var>)<var><a name="index-open_002doutput_002dbytevector-316"></a></var><br>
<blockquote><p>These applicative return a fresh output port that accumulates
characters or unsigned bytes.  The accumulated data can be obtained
via applicatives <code>get-ouput-string</code> and
<code>get-output-bytevector</code>, respectively.

        <p>SOURCE NOTE: This are taken from r7rs. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>close-input-file</b> (<var>close-input-file input-port</var>)<var><a name="index-close_002dinput_002dfile-317"></a></var><br>
&mdash; Applicative: <b>close-output-file</b> (<var>close-output-file output-port</var>)<var><a name="index-close_002doutput_002dfile-318"></a></var><br>
<blockquote><p>  These applicatives close the port argument, so that no more
input/output may be performed on them, and the resources can be
freed.  If the port was already closed these applicatives have no
effect.

        <p>The result returned by applicatives <code>close-input-file</code> and
<code>close-output-file</code> is inert.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing.  There's probably a name error here.  These should
probably be called close-input-port &amp; close-output-port. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>close-input-port</b> (<var>close-input-port input-port</var>)<var><a name="index-close_002dinput_002dport-319"></a></var><br>
&mdash; Applicative: <b>close-output-port</b> (<var>close-output-port output-port</var>)<var><a name="index-close_002doutput_002dport-320"></a></var><br>
&mdash; Applicative: <b>close-port</b> (<var>close-port port</var>)<var><a name="index-close_002dport-321"></a></var><br>
<blockquote><p>  These applicatives close the port argument, so that no more
input/output may be performed on them, and the resources can be
freed.  If the port was already closed these applicatives have no
effect.  If at some time klisp provided input/ouput ports these could
be used to selectively close only one direction of the port.

        <p>The result returned by applicatives <code>close-input-port</code>,
<code>close-output-port</code>, and <code>close-port</code> is inert.

        <p>SOURCE NOTE: this is from r7rs. The equivalent
<code>close-input-file</code> and <code>close-output-file</code> are probably name
errors and only retained here till the draft standard rectifies them
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>read</b> (<var>read </var>[<var>textual-input-port</var>])<var><a name="index-read-322"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>read</code> reads &amp; returns the next parseable object
from the given port, or the <code>eof</code> if no objects remain.  If
<code>read</code> finds and unparseable object in the port, an error is
signaled.  In that case, the remaining position in the port is
unspecified.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>write</b> (<var>write object </var>[<var>textual-output-port</var>])<var><a name="index-write-323"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

     <!-- TODO add xref to external representation -->
        <p>Applicative <code>write</code> writes an external representation of
<code>object</code> to the specified port.  This may be an output-only
representation that can't be read by applicative <code>read</code> in cases
where the type of <code>object</code> doen't have a parseable external
representation (e.g. combiners and environments).  The result returned
by <code>write</code> is inert.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>write-simple</b> (<var>write-simple object </var>[<var>port</var>])<var><a name="index-write_002dsimple-324"></a></var><br>
<blockquote><p>Applicative <code>write-simple</code> is like <code>write</code> except that it
doesn't write sharing info. It will hang if handed a cyclic structure. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>call-with-input-file</b> (<var>call-with-input-file string combiner</var>)<var><a name="index-call_002dwith_002dinput_002dfile-325"></a></var><br>
&mdash; Applicative: <b>call-with-output-file</b> (<var>call-with-output-file string combiner</var>)<var><a name="index-call_002dwith_002doutput_002dfile-326"></a></var><br>
<blockquote><p>  These applicatives open file named in <code>string</code> for textual
input/output respectively and call their <code>combiner</code> argument in a
fresh empty environment passing it as a sole operand the opened port. 
When/if the combiner normally returns a value the port is closed and
that value is returned as the result of the applicative.

        <p>SOURCE NOTE: this is enumerated in the Kernel report but the text is
still missing. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>load</b> (<var>load string</var>)<var><a name="index-load-327"></a></var><br>
<blockquote><!-- TODO add xref, open/input, read -->
        <p>Applicative <code>load</code> opens the file named <code>string</code> for
textual input; reads objects from the file until the end of the file
is reached; evaluates those objects consecutively in the created
environment.  The result from applicative <code>load</code> is inert.

        <p>SOURCE NOTE: load is enumerated in the Kernel report, but the
description is not there yet.  This seems like a sane way to define
it, taking the description of <code>get-module</code> that there is in the
report.  The one detail that I think is still open, is whether to
return <code>#inert</code> (as is the case with klisp currently) or rather
return the value of the last evaluation. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>require</b><var><a name="index-require-328"></a></var><br>
<blockquote><p>TODO
</p></blockquote></div>

   <p>TODO

<div class="defun">
&mdash; Applicative: <b>get-module</b> (<var>get-module string </var>[<var>environment</var>])<var><a name="index-get_002dmodule-329"></a></var><br>
<blockquote><!-- TODO add xref standard-environment, open/input, read -->
        <p>Applicative <code>get-module</code> creates a fresh standard environment;
opens the file named <code>string</code> for textual input; reads objects
from the file until the end of the file is reached; evaluates those
objects consecutively in the created environment; and, lastly, returns
the created environment.  If the optional argument <code>environment</code>
is specified, the freshly created standard environment is augmented,
prior to evaluating read expressions, by binding symbol
<code>module-parameters</code> to the <code>environment</code> argument. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>eof-object?</b> (<var>eof-object? . objects</var>)<var><a name="index-eof_002dobject_003f-330"></a></var><br>
<blockquote><p>  The primitive type predicate for type eof.  <code>eof-object?</code>
returns true iff all the objects in <code>objects</code> are of type eof.

        <p>SOURCE NOTE: This is not in the report, the idea is from Scheme. 
The <code>eof-object?</code> name is also from Scheme, but this will
probably be changed to just <code>eof?</code>, for consistency with the other
primitive type predicates. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>read-char</b> (<var>read-char </var>[<var>textual-input-port</var>])<var><a name="index-read_002dchar-331"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>read-char</code> reads and returns a character (not
an external representation of a character) from the specified port, or
an <code>eof</code> if the end of file was reached.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>peek-char</b> (<var>peek-char </var>[<var>textual-input-port</var>])<var><a name="index-peek_002dchar-332"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>peek-char</code> reads and returns a character (not
an external representation of a character) from the specified port, or
an <code>eof</code> if the end of file was reached.  The position of the port
remains unchanged so that new call to <code>peek-char</code> or
<code>read-char</code> on the same port return the same character.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>char-ready?</b> (<var>char-ready? </var>[<var>textual-input-port</var>])<var><a name="index-char_002dready_003f-333"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Predicate <code>char-ready?</code> checks to see if a character is
available in the specified port.  If it returns true, then a
<code>read-char</code> or <code>peek-char</code> on that port is guaranteed not to
block/hang.  For now in klisp this is hardcoded to <code>#t</code> because
the code to do this is non-portable.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>write-char</b> (<var>write-char char </var>[<var>textual-output-port</var>])<var><a name="index-write_002dchar-334"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>write-char</code> writes the <code>char</code> character (not
an external representation of the character) to the specified port. 
The result returned by <code>write-char</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>newline</b> (<var>newline </var>[<var>textal-ouput-port</var>])<var><a name="index-newline-335"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>newline</code> writes a newline to the specified port. 
The result returned by <code>newline</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>display</b> (<var>display object </var>[<var>textual-output-port</var>])<var><a name="index-display-336"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>display</code> behaves like <code>write</code> except that
strings are not enclosed in double quotes and no character is escaped
within those strings and character objects are output as if by
<code>write-char</code> instead of <code>read</code>. The result returned by
<code>display</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>read-u8</b> (<var>read-u8 </var>[<var>textual-input-port</var>])<var><a name="index-read_002du8-337"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>read-u8</code> reads and returns a byte as an exact
unsigned integer between 0 and 255 inclusive (not an external
representation of a byte) from the specified port, or an <code>eof</code> if
the end of file was reached.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>peek-u8</b> (<var>peek-u8 </var>[<var>textual-input-port</var>])<var><a name="index-peek_002du8-338"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>peek-u8</code> reads and returns a byte as an exact
unsigned integer between 0 and 255 inclusive (not an external
representation of a byte) from the specified port, or an <code>eof</code> if
the end of file was reached.  The position of the port remains
unchanged so that new call to <code>peek-u8</code> or <code>read-u8</code> on the
same port return the same byte.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>u8-ready?</b> (<var>u8-ready? </var>[<var>textual-input-port</var>])<var><a name="index-u8_002dready_003f-339"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>input-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Predicate <code>u8-ready?</code> checks to see if a byte is
available in the specified port.  If it returns true, then a
<code>read-u8</code> or <code>peek-u8</code> on that port is guaranteed not to
block/hang.  For now in klisp this is hardcoded to <code>#t</code> because
the code to do this is non-portable.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>write-u8</b> (<var>write-u8 u8 </var>[<var>textual-output-port</var>])<var><a name="index-write_002du8-340"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If the
port is closed, an error is signaled.

        <p>Applicative <code>write-u8</code> writes the byte represented by the
unsigned integer <code>u8</code>, that should be between 0 and 255 inclusive,
(not an external representation of byte) to the specified port.  The
result returned by <code>write-u8</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>flush-output-port</b> (<var>flush-output-port </var>[<var>output-port</var>])<var><a name="index-flush_002doutput_002dport-341"></a></var><br>
<blockquote><p>  If the <code>port</code> optional argument is not specified, then the
value of the <code>output-port</code> keyed dynamic variable is used.  If
the <code>port</code> is closed or if it is not an output port, an error is
signaled.

        <p>Applicative <code>flush-ouput-port</code> flushes any buffered data in the
output port to the underlying file or device. The result returned by
<code>flush-output-port</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from r7rs Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>file-exists?</b> (<var>file-exists? string</var>)<var><a name="index-file_002dexists_003f-342"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for a file.

        <p>Predicate <code>file-exists?</code> checks to see if a file named
<code>string</code> exists.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from r7rs Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>delete-file</b> (<var>delete-file string</var>)<var><a name="index-delete_002dfile-343"></a></var><br>
<blockquote><p>  <code>string</code> should be the name/path for an existing file.

        <p>Applicative <code>delete-file</code> deletes the file named <code>string</code>. 
If it doesn't exists or can't be deleted, an error is signaled. The
result returned by <code>delete-file</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel, it is taken from r7rs Scheme. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>rename-file</b> (<var>rename-file string1 string2</var>)<var><a name="index-rename_002dfile-344"></a></var><br>
<blockquote><p>  <code>string1</code> should be the name/path for an existing file,
<code>string2</code> should be the name/path for a non existing file.

        <p>Applicative <code>rename-file</code> renames the file named <code>string1</code>
to <code>string2</code>. If the file doesn't exists or can't be renamed for
any reason, an error is signaled. The result returned by
<code>rename-file</code> is inert.

        <p>SOURCE NOTE: this is missing from Kernel AND Scheme, it is taken
from C, being quite similar to <code>delete-file</code>. 
</p></blockquote></div>

<!-- appendices -->
<!-- TODO -->
<!-- *-texinfo-*- -->
<!-- TODO correct prev node -->
   </body></html>

