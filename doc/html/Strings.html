<html lang="en">
<head>
<title>Strings - klisp Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="klisp Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Numbers.html#Numbers" title="Numbers">
<link rel="next" href="Characters.html#Characters" title="Characters">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
<div class="node">
<a name="Strings"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Characters.html#Characters">Characters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Numbers.html#Numbers">Numbers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">15 Strings</h2>

<p><a name="index-strings-232"></a>
  A string is an object that represent a sequence of characters (for
now, only ASCII is supported in klisp, in the future, full UNICODE
will be supported).  The external representation of strings consists
of a leading &ldquo;"&rdquo;, the characters of the string and a closing &ldquo;"&rdquo;. 
Both double quote and backslash should be escaped to appear withing
strings.  Some other characters also have an escaped form for
convenience.  All of these are written with a leading slash (&ldquo;\&rdquo;). 
In klisp these are: double quote (&ldquo;\"&rdquo;), backslash (&ldquo;\\&rdquo;), null
(&ldquo;\0&rdquo;), alarm (&ldquo;\a&rdquo;), backspace (&ldquo;\b&rdquo;), tab (&ldquo;\t&rdquo;), newline
(&ldquo;\n&rdquo;), return (&ldquo;\r&rdquo;), vertical tab (&ldquo;\v&rdquo;), and formfeed
(&ldquo;\f&rdquo;).  You can also use inline hex escapes to include arbitary
unicode codepoints (only ASCII range supported for now).  The syntax
is &ldquo;\x&lt;hex codepoint&gt;;&rdquo;.  New lines can be escaped to simplify the
accomodation of literal strings in source code, to do this: use &ldquo;\&rdquo;
followed by any ammount of intraline whitespace, a new line and
another ammount of intraline whitespace.  All of that intraline
whitespace and the newline, together with the leading slash is
discarded by the reader and doesn't end up in the string being read.

   <p>A string has a length that is fixed at creation time, and as many
characters, indexed from <code>0</code> to <code>length-1</code>.

   <p>Strings may be mutable or immutable.  If an attempt is made to
mutate an immutable string, an error is signaled.  Two immutable
strings are &ldquo;eq?&rdquo; iff they are &ldquo;equal?&rdquo;.  Two mutable strings are
&ldquo;eq?&rdquo; if they were created by the same constructor call.  Two
mutable strings are &ldquo;equal?&rdquo; iff they are &ldquo;string=?&rdquo;.  For now it
is undefined if a mutable and an immutable strings that are
&ldquo;string=?&rdquo; are &ldquo;equal?&rdquo; or not.  The only exception is the empty
string.  There is only one empty string (all empty strings are &ldquo;eq?&rdquo;
to each other) and it should be considered immutable.  Even if an
attempt is made to return a new empty string (like calling
<code>(string)</code>, the canonical immutable empty string is returned. 
The string type is encapsulated.

   <p>SOURCE NOTE: This section is still missing from the report.  The
features defined here were taken mostly from r7rs scheme.  It is
possible that in the future, klisp only admits immutable strings (like
lua and java), and that operations for contructing strings are moved
to a new type (like Java's StringBuilder/StringBuffer).  But for now,
compatibility with r7rs was preferred/simpler.

<div class="defun">
&mdash; Applicative: <b>string?</b> (<var>string? . objects</var>)<var><a name="index-string_003f-233"></a></var><br>
<blockquote><p>  The primitive type predicate for type string.  <code>string?</code>
returns true iff all the objects in <code>objects</code> are of type
string. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>immutable-string?</b> (<var>immutable-string? objects</var>)<var><a name="index-immutable_002dstring_003f-234"></a></var><br>
&mdash; Applicative: <b>mutable-string?</b> (<var>mutable-string? objects</var>)<var><a name="index-mutable_002dstring_003f-235"></a></var><br>
<blockquote><p>The primitive type predicates for types immutable string and mutable
string.  These return true iff all the objects in <code>objects</code> are of
type immutable string or mutable string respectively.

        <p>SOURCE NOTE: these aren't provided in the Kernel report, but added for
convenience.  These can be implemented in standard kernel by using guards. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string=?</b> (<var>string=? . strings</var>)<var><a name="index-string_003d_003f-236"></a></var><br>
&mdash; Applicative: <b>string&lt;?</b> (<var>string&lt;? . strings</var>)<var><a name="index-string_003c_003f-237"></a></var><br>
&mdash; Applicative: <b>string&lt;=?</b> (<var>string&lt;=? . strings</var>)<var><a name="index-string_003c_003d_003f-238"></a></var><br>
&mdash; Applicative: <b>string&gt;?</b> (<var>string&gt;? . strings</var>)<var><a name="index-string_003e_003f-239"></a></var><br>
&mdash; Applicative: <b>string&gt;=?</b> (<var>string&gt;=? . strings</var>)<var><a name="index-string_003e_003d_003f-240"></a></var><br>
<blockquote><p>  These predicates compare any number of strings by their
lexicographic order. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-ci=?</b> (<var>string-ci=? . strings</var>)<var><a name="index-string_002dci_003d_003f-241"></a></var><br>
&mdash; Applicative: <b>string-ci&lt;?</b> (<var>string-ci&lt;? . strings</var>)<var><a name="index-string_002dci_003c_003f-242"></a></var><br>
&mdash; Applicative: <b>string-ci&lt;=?</b> (<var>string-ci&lt;=? . strings</var>)<var><a name="index-string_002dci_003c_003d_003f-243"></a></var><br>
&mdash; Applicative: <b>string-ci&gt;?</b> (<var>string-ci&gt;? . strings</var>)<var><a name="index-string_002dci_003e_003f-244"></a></var><br>
&mdash; Applicative: <b>string-ci&gt;=?</b> (<var>string-ci&gt;=? . strings</var>)<var><a name="index-string_002dci_003e_003d_003f-245"></a></var><br>
<blockquote><p>  These predicates convert the strings to lowercase and then compare
them using their lexicographic order. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>make-string</b> (<var>make-string k </var>[<var>char</var>])<var><a name="index-make_002dstring-246"></a></var><br>
<blockquote><p>  Applicative <code>make-string</code> constructs and returns a new mutable
string of length <code>k</code>.  If <code>char</code> is specified, then all
characters in the returned string are <code>char</code>, otherwise the
content of the string is unspecified. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string</b> (<var>string . chars</var>)<var><a name="index-string-247"></a></var><br>
<blockquote><p>  Applicative <code>string</code> contructs and return a new mutable string
composed of the character arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-length</b> (<var>string-length string</var>)<var><a name="index-string_002dlength-248"></a></var><br>
<blockquote><p>  Applicative <code>string-length</code> returns the length of
<code>string</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-ref</b> (<var>string-ref string k</var>)<var><a name="index-string_002dref-249"></a></var><br>
<blockquote><p>  Applicative <code>string-ref</code> returns the character of <code>string</code>
at position <code>k</code>.  If <code>k</code> is out of bounds (i.e. less than
<code>0</code> or greater or equal than <code>(string-length string)</code>) an error is
signaled. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-set!</b> (<var>string-set! string k char</var>)<var><a name="index-string_002dset_0021-250"></a></var><br>
<blockquote><p>  Applicative <code>string-set!</code> replaces the character with index
<code>k</code> in <code>string</code> with character <code>char</code>.  If <code>k</code> is
out of bounds, or <code>string</code> is immutable, an error is signaled. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-fill!</b> (<var>string-fill! string char</var>)<var><a name="index-string_002dfill_0021-251"></a></var><br>
<blockquote><p>  Applicative <code>string-fill!</code> replaces all the characters in
<code>string</code> with character <code>char</code>.  If <code>string</code> is an
immutable string, an error is signaled. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>substring</b> (<var>substring string k1 k2</var>)<var><a name="index-substring-252"></a></var><br>
<blockquote><p>  Both <code>k1</code> &amp; <code>k2-1</code> should be valid indexes in
<code>string</code>.  Also it should be the case that <code>k1 &lt;= k2</code>.

        <p>Applicative <code>substring</code> constructs and returns a new mutable
string with length <code>k2 - k1</code>, with the characters from
<code>string</code>, starting at index <code>k1</code> (inclusive) and ending at
index <code>k2</code> (exclusive). 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-append</b> (<var>string-append . strings</var>)<var><a name="index-string_002dappend-253"></a></var><br>
<blockquote><p>  Applicative <code>string-append</code> constructs and returns a new
mutable string consisting of the concatenation of all its arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-copy</b> (<var>string-copy string</var>)<var><a name="index-string_002dcopy-254"></a></var><br>
<blockquote><p>  Applicative <code>string-copy</code> constructs and returns a new mutable
string with the same length and characters as <code>string</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-&gt;immutable-string</b> (<var>string-&gt;immutable-string string</var>)<var><a name="index-string_002d_003eimmutable_002dstring-255"></a></var><br>
<blockquote><p>  Applicative <code>string-&gt;immutable-string</code> constructs and returns a
new immutable string with the same length and characters as
<code>string</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-&gt;list</b> (<var>string-&gt;list string</var>)<var><a name="index-string_002d_003elist-256"></a></var><br>
&mdash; Applicative: <b>list-&gt;string</b> (<var>list-&gt;string chars</var>)<var><a name="index-list_002d_003estring-257"></a></var><br>
&mdash; Applicative: <b>string-&gt;vector</b> (<var>string-&gt;vector string</var>)<var><a name="index-string_002d_003evector-258"></a></var><br>
&mdash; Applicative: <b>vector-&gt;string</b> (<var>vector-&gt;string vchars</var>)<var><a name="index-vector_002d_003estring-259"></a></var><br>
&mdash; Applicative: <b>string-&gt;bytevector</b> (<var>string-&gt;bytevector string</var>)<var><a name="index-string_002d_003ebytevector-260"></a></var><br>
&mdash; Applicative: <b>bytevector-&gt;string</b> (<var>bytevector-&gt;string bvchars</var>)<var><a name="index-bytevector_002d_003estring-261"></a></var><br>
<blockquote><p>These applicatives convert between strings and list of characters,
vectors of characters, and bytevectors of characters.  The objects
returned by these applicatives are always mutable. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>string-upcase</b> (<var>string-upcase string</var>)<var><a name="index-string_002dupcase-262"></a></var><br>
&mdash; Applicative: <b>string-downcase</b> (<var>string-downcase string</var>)<var><a name="index-string_002ddowncase-263"></a></var><br>
&mdash; Applicative: <b>string-titlecase</b> (<var>string-titlecase string</var>)<var><a name="index-string_002dtitlecase-264"></a></var><br>
&mdash; Applicative: <b>string-foldcase</b> (<var>string-foldcase string</var>)<var><a name="index-string_002dfoldcase-265"></a></var><br>
<blockquote><p>These applicatives perform the respective case folding on the passed
<code>string</code> and return a new mutable strings as a result.  The
original <code>string</code> is not modified.  For now in klisp only ASCII
is implemented, and so <code>string-foldcase</code> is the same as
<code>string-downcase</code>. 
</p></blockquote></div>

<!-- *-texinfo-*- -->
   </body></html>

