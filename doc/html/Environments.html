<html lang="en">
<head>
<title>Environments - klisp Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="klisp Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Pairs-and-lists.html#Pairs-and-lists" title="Pairs and lists">
<link rel="next" href="Combiners.html#Combiners" title="Combiners">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
<div class="node">
<a name="Environments"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Combiners.html#Combiners">Combiners</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Pairs-and-lists.html#Pairs-and-lists">Pairs and lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">8 Environments</h2>

<p><a name="index-environments-104"></a><a name="index-ignore-105"></a>
  An environment consists of a set of bindings, and a list of zero or
more references to other environments called its parents. 
<!-- TODO add xref to lookup algo & ground env -->
Changing the set of bindings of an environment, or setting the
referent of the reference in a binding, is a mutation of the
environment. (Changing the parent list, or a referent in the list,
would be a mutation of the environment too, but there is no facility
provided to do it.) The Kernel data type environment is encapsulated. 
Among other things, there is no facility provided for enumerating all
the variables exhibited by an environment (which is not required,
after all, to be a finite set), and no facility for identifying the
parents of an environment.  Two environments are <code>equal?</code> iff
they are <code>eq?</code>.

   <p>An auxiliary data type used by combiners that perform binding is
ignore. The ignore type consists of a single immutable value, having
external representation <code>#ignore</code>.  The ignore type is
encapsulated.

<div class="defun">
&mdash; Applicative: <b>environment?</b> (<var>environment? . objects</var>)<var><a name="index-environment_003f-106"></a></var><br>
<blockquote><p>  The primitive type predicate for type environment. 
<code>environment?</code> returns true iff all the objects in <code>objects</code>
are of type environment. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>ignore?</b> (<var>ignore? . objects</var>)<var><a name="index-ignore_003f-107"></a></var><br>
<blockquote><p>  The primitive type predicate for type ignore.  <code>ignore?</code>
returns true iff all the objects in <code>objects</code> are of type ignore. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>eval</b> (<var>eval expression environment</var>)<var><a name="index-eval-108"></a></var><br>
<blockquote><!-- TODO add xref to tail context -->
     <!-- TODO add xref to evaluation description -->
        <p>The <code>eval</code> applicative evaluates <code>expression</code> in
<code>environment</code>, as a tail context, returning the resulting value. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>make-environment</b> (<var>make-environment . environments</var>)<var><a name="index-make_002denvironment-109"></a></var><br>
<blockquote><p>  The applicative constructs and returns a new environment, with
initially no local bindings, and parent environments the environments
listed in <code>environments</code>. The constructed environment internally
stores its list of parents independent of the first-class list
<code>environments</code>, so that subsequent mutation of
<code>environments</code> will not change the parentage of the constructed
environment. If the provided list <code>environments</code> is cyclic, the
constructed environment will still check each of its parents at most
once, and signal an error if no binding is found locally or in any of
<!-- TODO add xref to cons, mutation, eq? and equal? -->
the parents.  No two objects returned by different calls to
<code>make-environment</code> are <code>eq?</code> to each other. 
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$define!</b> (<var>$define! &lt;definiend&gt; &lt;expression&gt;</var>)<var><a name="index-g_t_0024define_0021-110"></a></var><br>
<blockquote><!-- TODO move formal parameter tree definition to the intro -->
     <!-- TODO move matching definition to the intro -->
        <p><code>&lt;definiend&gt;</code> should be a formal parameter tree, as described
below; otherwise, an error is signaled.

        <p>The <code>$define!</code> operative evaluates <code>&lt;expression&gt;</code> in the
dynamic environment and matches <code>&lt;definiend&gt;</code> to the result in
the dynamic environment, binding each symbol in definiend in the
dynamic environment to the corresponding part of the result; the
matching process will be further described below. The ancestors of the
dynamic environment, if any, are unaffected by the matching process,
as are all bindings, local to the dynamic environment, of symbols not
in <code>&lt;definiend&gt;</code>.  The result returned by <code>$define!</code> is
inert.

        <p>A formal parameter tree has the following context-free structure:
     <pre class="example">          ptree:: symbol | #ignore | () | (ptree . ptree)
</pre>
        <p>That is, a formal parameter tree is either a symbol, or ignore, or
nil, or a pair whose car and cdr referents are formal parameter trees. 
A formal parameter tree must also be acyclic, and no one symbol can
occur more than once in it.  It is not an error for a pair in the tree
to be reachable from the root by more than one path, as long as there
is no cycle; but if any particular symbol were reachable from the root
by more than one path, that would count as occurring more than once. 
Thus, if a pair is reachable by more than one path, there must be no
symbols reachable from it.

        <p>Matching of a formal parameter tree <code>t</code> to an object <code>o</code>
in an environment <code>e</code> proceeds recursively as follows.  If the
matching process fails, an error is signaled.
          <ul>
<li>If <code>t</code> is a symbol, then <code>t</code> is bound to <code>o</code> in
<code>e</code>.

          <li>If <code>t</code> is <code>#ignore</code>, no action is taken.

          <li>If <code>t</code> is nil, then <code>o</code> must be nil (else matching fails).

          <li>If <code>t</code> is a pair, then <code>o</code> must be a pair (else matching
fails). The car of <code>t</code> is matched to the car of <code>o</code> in
<code>e</code>, and the cdr of <code>t</code> is matched to the cdr of <code>o</code> in
<code>e</code>. 
</ul>
        </p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$let</b> (<var>$let &lt;bindings&gt; . &lt;objects&gt;</var>)<var><a name="index-g_t_0024let-111"></a></var><br>
<blockquote><!-- TODO add xref to formal parameter tree -->
        <p><code>&lt;bindings&gt;</code> should be a finite list of
formal-parameter-tree/expression pairings, each of the form
<code>(formals expression)</code>, where each <code>formals</code> is a formal
parameter, and no symbol occurs in more than one of the
<code>formals</code>.

        <p>The following equivalence holds:

     <pre class="example">          ($let ((form1 exp1) ... (formn expn)) . objects) ==
            (($lambda (form1 ... formn) . objects) exp1 ... expn)
</pre>
        <!-- TODO add xref to tail context -->
        <p>Thus, the <code>expk</code> are first evaluated in the dynamic environment,
in any order; then a child environment <code>e</code> of the dynamic
environment is created, with the <code>formk</code> matched in <code>e</code> to
the results of the evaluations of the <code>expk</code>; and finally the
subexpressions of <code>objects</code> are evaluated in <code>e</code> from left
to right, with the last (if any) evaluated as a tail context, or if
<code>objects</code> is empty the result is inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$binds?</b> (<var>$binds? &lt;exp&gt; . &lt;symbols&gt;</var>)<var><a name="index-g_t_0024binds_003f-112"></a></var><br>
<blockquote><p>  Operative <code>$binds</code> evaluates <code>&lt;exp&gt;</code> in the dynamic
environment; call the result <code>env</code>.  <code>env</code> must be an
environment.  The operative is a predicate that returns true iff all
its later operands, <code>&lt;symbols&gt;</code>, are visibly bound in <code>env</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>get-current-environment</b> (<var>get-current-environment</var>)<var><a name="index-get_002dcurrent_002denvironment-113"></a></var><br>
<blockquote><p>  The <code>get-current-environment</code> applicative returns the dynamic
environment in which it is called. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>make-kernel-standard-environment</b> (<var>make-kernel-standard-environment</var>)<var><a name="index-make_002dkernel_002dstandard_002denvironment-114"></a></var><br>
<blockquote><!-- TODO add xref to ground environment/standard environment -->
        <p>The <code>make-kernel-standard-environment</code> applicative returns a
standard environment; that is, a child of the ground environment with
no local bindings. 
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$let*</b> (<var>$let* &lt;bindings&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024let_002a-115"></a></var><br>
<blockquote><!-- TODO add xref to formal ptree -->
        <p><code>&lt;bindings&gt;</code> should be a finite list of
formal-parameter-tree/expression pairings, each of the form
<code>(formals expression)</code>, where each <code>formals</code> is a formal
parameter tree; <code>&lt;body&gt;</code> should be a list of expressions.

        <p>The following equivalences hold:

     <pre class="example">          ($let* () . body) == ($let () . body)
          
          ($let* ((form exp) . bindings) . body) ==
            ($let ((form exp)) ($let* bindings . body))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$letrec</b> (<var>$letrec &lt;bindings&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024letrec-116"></a></var><br>
<blockquote><!-- add xref for $let -->
        <p><code>&lt;bindings&gt;</code> and <code>&lt;body&gt;</code> should be as described for
<code>$let</code>.

        <p>The following equivalence holds:
     <pre class="example">          ($letrec ((form1 exp1) ... (formn expn)) . body) ==
            ($let () ($define! (form1 ... formn) (list exp1 ... expn)) . body)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$letrec*</b> (<var>$letrec* &lt;bindings&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024letrec_002a-117"></a></var><br>
<blockquote><!-- TODO add xref to $let* -->
        <p><code>&lt;bindings&gt;</code> and <code>&lt;body&gt;</code> should be as described for
<code>$let*</code>.

        <p>The following equivalences hold:
     <pre class="example">          ($letrec* () . body) == ($letrec () . body)
          
          ($letrec* ((form exp) . bindings) . body) ==
            ($letrec ((form exp)) ($letrec* bindings . body))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$let-redirect</b> (<var>$let-redirect &lt;exp&gt; &lt;bindings&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024let_002dredirect-118"></a></var><br>
<blockquote><!-- TODO add xref to $let -->
        <p><code>&lt;bindings&gt;</code> and <code>&lt;body&gt;</code> should be as described for
<code>$let</code>.

        <p>The following equivalence holds:

     <pre class="example">          ($let-redirect exp ((form1 exp1) ... (formn . body) expn)) ==
            ((eval (list $lambda (form1 ... formn) body) exp) expn ... expn)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$let-safe</b> (<var>$let-safe &lt;bindings&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024let_002dsafe-119"></a></var><br>
<blockquote><!-- TODO add xref to $let -->
        <p><code>&lt;bindings&gt;</code> and <code>&lt;body&gt;</code> should be as described for
<code>$let</code>.

        <p>The following equivalence holds:

     <pre class="example">          ($let-safe bindings . body) ==
            ($let-redirect (make-kernel-standard-environment) bindings . body)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$remote-eval</b> (<var>$remote-eval &lt;exp1&gt; &lt;exp2&gt;</var>)<var><a name="index-g_t_0024remote_002deval-120"></a></var><br>
<blockquote><!-- TODO add xref to tail context -->
        <p>Operative <code>$remote-eval</code> evaluates <code>&lt;exp2&gt;</code> in the dynamic
environment, then evaluates <code>&lt;exp1&gt;</code> as a tail context in the
environment that must result from the first evaluation. 
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$bindings-&gt;environment</b> (<var>$bindings-&gt;environment . &lt;bindings&gt;</var>)<var><a name="index-g_t_0024bindings_002d_003eenvironment-121"></a></var><br>
<blockquote><!-- TODO add xref to $let -->
        <p><code>&lt;bindings&gt;</code> should be as described for <code>$let</code>.

        <p>The following equivalence holds:

     <pre class="example">          ($bindings-&gt;environment . bindings) ==
            ($let-redirect (make-environment) bindings (get-current-environment))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Applicative: <b>eval-string</b> (<var>eval-string string environment</var>)<var><a name="index-eval_002dstring-122"></a></var><br>
<blockquote><p><code>string</code> should be the external representation of a single
object.  If none or more than one external representation is found in
<code>string</code> then an error is signaled.

        <p>Applicative <code>eval-string</code> reads an external representation from
string, and evaluates the resulting object in <code>environment</code>, as a
tail context, returning the resulting value. 
<!-- TODO add xref to tail context. -->
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$set!</b> (<var>$set! &lt;exp1&gt; &lt;formals&gt; &lt;exp2&gt;</var>)<var><a name="index-g_t_0024set_0021-123"></a></var><br>
<blockquote><!-- TODO add xref to $define! -->
     <!-- TODO add xref to matching algo -->
        <p><code>&lt;formals&gt;</code> should be as described for the <code>$define!</code>
operative.  The <code>$set!</code> operative evaluates <code>&lt;exp1&gt;</code> and
<code>&lt;exp2&gt;</code> in the dynamic environment; call the results <code>env</code>
and <code>obj</code>.  If <code>env</code> is not an environment, an error is
signaled.  Then the operative matches <code>&lt;formals&gt;</code> to <code>obj</code>
in environment <code>env</code>.  Thus, the symbols of <code>&lt;formals&gt;</code> are
bound in <code>env</code> to the corresponding parts of <code>obj</code>. 
The result returned by <code>$set!</code> is inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Operative: <b>$provide!</b> (<var>$provide! &lt;symbols&gt; . &lt;body&gt;</var>)<var><a name="index-g_t_0024provide_0021-124"></a></var><br>
<blockquote><p>  <code>&lt;symbols&gt;</code> must be a finite list of symbols, containing no
duplicates.  <code>&lt;body&gt;</code> must be a finite list.

        <p>The <code>$provide!</code> operative constructs a child <code>e</code> of the
dynamic environment <code>d</code>; evaluates the elements of <code>&lt;body&gt;</code>
in <code>e</code>, from left to right, discarding all of the results; and
exports all of the bindings of symbols in <code>&lt;symbols&gt;</code> from
<code>e</code> to <code>d</code>, i.e., binds each symbol in <code>d</code> to the
result of looking it up in <code>e</code>.  The result returned by
<code>$provide!</code>  is inert.

        <p>The following equivalence holds:

     <pre class="example">          ($provide!  symbols . body) ==
          ($define!  symbols ($let () ($sequence . body) (list . symbols)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Operative: <b>$import!</b> (<var>$import! &lt;exp&gt; . &lt;symbols&gt;</var>)<var><a name="index-g_t_0024import_0021-125"></a></var><br>
<blockquote><p>  <code>&lt;symbols&gt;</code> must be a list of symbols.

        <p>The <code>$import!</code> operative evaluates <code>&lt;exp&gt;</code> in the dynamic
environment; call the result <code>env</code>. <code>env</code> must be an
environment. Each distinct symbol <code>s</code> in <code>&lt;symbols&gt;</code> is
evaluated in <code>env</code>, and <code>s</code> is bound in the dynamic
environment to the result of this evaluation.

        <p>The following equivalence holds:

     <pre class="example">          ($import! exp . symbols) ==
          ($define! symbols ($remote-eval (list symbols) exp))
</pre>
        </blockquote></div>

<!-- *-texinfo-*- -->
   </body></html>

