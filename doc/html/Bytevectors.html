<html lang="en">
<head>
<title>Bytevectors - klisp Reference Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="klisp Reference Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Vectors.html#Vectors" title="Vectors">
<link rel="next" href="Libraries.html#Libraries" title="Libraries">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Bytevectors"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Libraries.html#Libraries">Libraries</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Vectors.html#Vectors">Vectors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
<h2 class="chapter">19 Bytevectors</h2>

<p><a name="index-Bytevectors-370"></a>
A bytevector is an object that contains a sequence of bytes, that is,
exact integers between 0 and 255 inclusive.  A bytevector has a length
that is fixed at creation time, and as many bytes, indexed from
<code>0</code> to <code>length-1</code>.  Compared to vectors, bytevectors use
less size for each element.

   <p>Bytevectors may be mutable or immutable.  If an attempt is made to
mutate an immutable bytevector, an error is signaled.  Two immutable
bytevectors are &ldquo;eq?&rdquo; iff they are &ldquo;equal?&rdquo;.  Two mutable
bytevectors are &ldquo;eq?&rdquo; if they were created by the same constructor
call.  Two mutable bytevectors are &ldquo;equal?&rdquo; iff they have the same
length and have &ldquo;equal?&rdquo;  bytes in each position.  There is only one
empty bytevector (that is, a bytevector of length 0) and that
bytevector is immutable.  The bytevector type is encapsulated.

   <p>SOURCE NOTE: The report doesn't currently include bytevectors. They
are taken from r7rs scheme.

<div class="defun">
&mdash; Applicative: <b>bytevector?</b> (<var>bytevector? . obje</var>)<var><a name="index-bytevector_003f-371"></a></var><br>
<blockquote><p>The primitive type predicate for type bytevector.  <code>bytevector?</code>
returns true iff all the objects in <code>objects</code> are of type
bytevector. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>immutable-bytevector?</b> (<var>immutable-bytevector? objects</var>)<var><a name="index-immutable_002dbytevector_003f-372"></a></var><br>
&mdash; Applicative: <b>mutable-bytevector?</b> (<var>mutable-bytevector? objects</var>)<var><a name="index-mutable_002dbytevector_003f-373"></a></var><br>
<blockquote><p>The primitive type predicates for types immutable bytevector and
mutable bytevector.  These return true iff all the objects in
<code>objects</code> are of type immutable bytevector or mutable bytevector
respectively. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>make-bytevector</b> (<var>make-bytevector k </var>[<var>u8</var>])<var><a name="index-make_002dbytevector-374"></a></var><br>
<blockquote><p>Applicative <code>make-bytevector</code> constructs and returns a new
mutable bytevector of length <code>k</code>.  If <code>u8</code> is specified,
then all bytes in the returned bytevector are <code>obj</code>, otherwise
the content of the bytevector is unspecified. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-length</b> (<var>bytevector-length bytevector</var>)<var><a name="index-bytevector_002dlength-375"></a></var><br>
<blockquote><p>Applicative <code>bytevector-length</code> returns the length of
<code>bytevector</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-ref</b> (<var>bytevector-ref bytevector k</var>)<var><a name="index-bytevector_002dref-376"></a></var><br>
<blockquote><p>Applicative <code>bytevector-ref</code> returns the byte of
<code>bytevector</code> at position <code>k</code>.  If <code>k</code> is out of bounds
(i.e. less than <code>0</code> or greater or equal than
<code>(bytevector-length bytevector)</code>) an error is signaled. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-set!</b> (<var>bytevector-set! bytevector k u8</var>)<var><a name="index-bytevector_002dset_0021-377"></a></var><br>
<blockquote><p>Applicative <code>bytevector-set!</code> replaces the byte with index
<code>k</code> in <code>bytevector</code> with byte <code>u8</code>.  If <code>k</code> is out
of bounds, or <code>bytevector</code> is immutable, an error is
signaled. The result returned by <code>bytevector-set!</code> is inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector</b> (<var>bytevector . u8s</var>)<var><a name="index-bytevector-378"></a></var><br>
<blockquote><p>Applicative <code>bytevector</code> contructs and return a new mutable
bytevector composed of the byte arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-&gt;list</b> (<var>bytevector-&gt;list bytevector</var>)<var><a name="index-bytevector_002d_003elist-379"></a></var><br>
&mdash; Applicative: <b>list-&gt;bytevector</b> (<var>list-&gt;bytevector u8s</var>)<var><a name="index-list_002d_003ebytevector-380"></a></var><br>
<blockquote><p>These applicatives convert between bytevectors and lists of bytes.  If
the list passed to <code>list-&gt;bytevector</code> contains an object that
isn't a byte, an error is signaled.  The objects returned by these
applicatives are always mutable. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-copy</b> (<var>bytevector-copy bytevector</var>)<var><a name="index-bytevector_002dcopy-381"></a></var><br>
<blockquote><p>Applicative <code>bytevector-copy</code> constructs and returns a new
mutable bytevector with the same length and bytes as
<code>bytevector</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-&gt;vector</b> (<var>bytevector-&gt;vector bytevector</var>)<var><a name="index-bytevector_002d_003evector-382"></a></var><br>
&mdash; Applicative: <b>vector-&gt;bytevector</b> (<var>vector-&gt;bytevector vector</var>)<var><a name="index-vector_002d_003ebytevector-383"></a></var><br>
<blockquote><p>These applicatives convert between bytevectors and vectors.  If a
vector containing objects other than bytes (exact integers between 0
and 255 inclusive) is passed to <code>vector-&gt;bytevector</code>, an error is
signaled.  The objects returned by these applicatives are always
mutable. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-copy!</b> (<var>bytevector-copy! bytevector1 bytevector2</var>)<var><a name="index-bytevector_002dcopy_0021-384"></a></var><br>
<blockquote><p>bytevector2 should have a length greater than or equal to that of
bytevector1.

        <p>Copies the bytes in bytevector1 to the corresponding positions in
bytevector2.  If bytevector2 is immutable, an error is signaled.  The
result returned by <code>bytevector-copy!</code> is inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-copy-partial</b> (<var>bytevector-copy-partial bytevector k1 k2</var>)<var><a name="index-bytevector_002dcopy_002dpartial-385"></a></var><br>
<blockquote><p>Both <code>k1</code> &amp; <code>k2</code> should be valid indexes in
<code>bytevector</code>.  Also it should be the case that <code>k1 &lt;= k2</code>.

        <p>Applicative <code>bytevector-copy-partial</code> constructs and returns a
new mutable bytevector with length <code>k2 - k1</code>, with the bytes from
<code>bytevector</code>, starting at index <code>k1</code> (inclusive) and ending
at index <code>k2</code> (exclusive). 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-copy-partial!</b> (<var>bytevector-copy-partial! bytevector1 k1 k2 bytevector2 k3</var>)<var><a name="index-bytevector_002dcopy_002dpartial_0021-386"></a></var><br>
<blockquote><p>Both <code>k1</code> &amp; <code>k2-1</code> should be valid indexes in
<code>bytevector1</code>.  Also it should be the case that <code>k1 &lt;= k2</code>. 
Both <code>k3</code> &amp; <code>k3 + (k2-k1) - 1</code> should be valid indexes in
<code>bytevector2</code>.

        <p>Applicative <code>bytevector-copy-partial!</code> copies bytes k1
(inclusive) through k2 (exclusive) from <code>bytevector1</code> to the
<code>k2-k1</code> positions in <code>bytevector2</code> starting at <code>k3</code>. 
If <code>bytevector2</code> is an immutable bytevector, an error is
signaled.  The result returned by <code>bytevector-copy-partial!</code> is
inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-fill!</b> (<var>bytevector-fill! bytevector u8</var>)<var><a name="index-bytevector_002dfill_0021-387"></a></var><br>
<blockquote><p>Applicative <code>bytevector-fill!</code> replaces all the bytes in
<code>bytevector</code> with byte <code>u8</code>.  If <code>bytevector</code> is an
immutable bytevector, an error is signaled.  The result
returned by <code>bytevector-fill!</code> is inert. 
</p></blockquote></div>

<div class="defun">
&mdash; Applicative: <b>bytevector-&gt;immutable-bytevector</b> (<var>bytevector-&gt;immutable-bytevector bytevector</var>)<var><a name="index-bytevector_002d_003eimmutable_002dbytevector-388"></a></var><br>
<blockquote><p>Applicative <code>bytevector-&gt;immutable-bytevector</code> constructs and
returns a new immutable bytevector with the same length and bytes as
<code>bytevector</code>. 
</p></blockquote></div>

<!-- *-texinfo-*- -->
   </body></html>

